컴퓨터 아키텍쳐와 운영체제
컴퓨터는 어떻게 프로그램과 메모리를 조직적으로 관리할까

컴퓨터 구조
폰노이만 

                ALU     
명령어	     ↑
메모리 ↔ 실행장치
	     ↑
	     ↓
	    I/O

하버드

                ALU     
명령어	     ↑
메모리 ↔ 실행장치 ↔ 데이터 메모리
	     ↑
	     ↓
	    I/O

두 구조의 유일한 차이는 메모리 배열 뿐, 동시에 명령어와 데이터를 가져올 수 없기 떄문에 폰노이만이 약간 더 느리다.
하버드는 좀 더 빠르지만 두번째 메모리를 처리하기 위한 버스가 더 필요하다.

그림과 같이 메모리와 I/O가 프로세서 코어와 같은 패키지에 들어 있지 않으면 이런 프로세서를 마이크로프로세서라고 부른다.
반면 모든 요소를 한 칩에 패키징하면 마이크로 컴퓨터라고 부른다.

칩 안에서 메모리가 차지하는 영역이 크기 때문에 일반적으로 마이크로프로세서보다 마이크로컴퓨터가 덜 강력하다.
아두이노는 마이크로컴퓨터 칩을 기반으로 만들어진 하버드 구조의 컴퓨터.

요약하면 마이크로프로세서는 보통 큰 시스템에 들어가는 부품으로 쓰이고, 마이크로컴퓨터는 식기세척기 등에서 찾을 수 있는
단일 칩으로 된 작은 컴퓨터다.

함수(또는 프로시저나 서브루틴)는 코드를 재사용하는 주요 수단.

스택 bfs dfs 스택 오버플로우 스택 언더플로우

인터럽트 

인터럽트 시스템은 적절한 신호가 들어오면 cpu 실행을 잠깐 중단시킬 수 있는 핀이나 전기 연결을 포함
핀은 칩에 연결된 전기적 접점을 뜻하는 말. 
인터럽트 요청 생성 -> 프로세서는 현재 실행중인 명령어를 끝까지 실행 -> 현재 실행중인 프로그램을 잠시 중단 시키고
인터럽트 핸들러라는 전혀 다른 프로그램을 실행 -> 인터럽트 핸들러가 필요한 작업을 다 마치고 나면 원래 실행 중이던
프로그램이 중단된 위치부터 다시 실행을 계속한다.


컴퓨터가 인터럽트 핸들러 위치를 찾을 수 있는 방법은 보통은 인터럽트 핸들러 주소를 저장하기로 약속한 메모리 주소가 존재
이 주소에는 여러 인터럽트 벡터가 들어 있고, 각 인터럽트 벡터는 cpu가 지원하는 각 인터럽트에 대한 핸들러 주소를 지정한다.
인터럽트 벡터는 단지 메모리 위치를 가리키는 포인터이다.

인터럽트를 중단시킬 수 있는 마스크가 있는 경우가 자주 있다. 인터럽트가 많이 있는 곳에는 인터럽타 간의 우선순위를 정해준다.
일정 시간이 지나면 인터럽트를 발생 시킬 수 있는 내장 타이머도 하나 이상 들어있다.

사용자프로그램 상태 또는 문맥은 레지스터의 상태와 프로그램이 사용 중인 메모리의 상태를 뜻한다. 이 때 메모리는 스택도 포함된다.


대부분의 마이크로프로세서는 메모리관리장치 mmu 가 있다.
가상주소와 물리주소를 구분한다. 프로그램은 가상주소를 사용해 작성되고, mmu는 가상 주소를 물리 주소로 변환해 준다.

mmu 주소의 하위부분은 물리적 주소범위, 상위는 페이지 테이블이라는 ram영역을 통해 주소를 변환


os는 자원분배를 관리
mmu를 사용해 사용자 프로그램에게 가상메모리를 제공 
demand paging  물리 메모리보다 요청이 크면 현재 필요하지 않은 메모리 페이지를 좀 느린 대용량 저장장치에 옮기고 
공간을 확보하고 다시 불러들임
이런 일련의 방식인 스와핑이 일어나면 시스템 성능이 크게 저하된다. 하지만 실행도 못하는것보다 느리게 하는게 맞다.
LRU 알고리즘이 좋다.

캐시는 집에있는 식품 저장고, 가게보다 훨씬 작지만 훨씬 빠르고 프로세서와 같은 속도로 작동
가게에서 시리얼을 한 개만 가져오는 대신 보통 가방에 몇가지 시리얼을 담아서 집으로 가져온다. 메모리에 접근하는 방식이 
순차적이 아니어서 캐시 실패가 일어나도 cpu는 고속 메모리 접근이 가능하기 때문에 좀 더 유리하다. 캐시 실패는 cpu가 캐시에서
어떤 내용을 찾았는데 캐시에 그 데이터가 없어서 메모리를 읽어야 하는 경우를 뜻한다. 캐시적중은 cpu가 원하는 내용을 캐시에서
찾은 경우.














