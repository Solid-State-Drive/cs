

## 컴퓨터 아키텍처와 운영체제

> 컴퓨터 아키텍처 : 컴퓨터의 여러 구성요초를 배치하는 방법
>
> 운영체제(OS, operating system) : 프로그램들의 실행을 제어하기 위한 감독 프로그램



### 기본적인 구조 요소들

- 컴퓨터 구조 - 폰 노이만 구조 / 하버드 구조
- 두 구조의 유일한 차이는 메모리 배열
  - 폰 노이만 구조는 동시에 명령어와 데이터를 가져올 수 없어서 하버드 구조보다 느리다.
- 프로세서 코어
  - 예전 CPU라고 부르던 것을 요즘은 프로세서 코어라 부른다.
  - 이런 코어가 여럿 들어가는 멀티코어 프로세서가 이제는 일반적으로 쓰인다.
- 마이크로프로세서와 마이크로 컴퓨터
  - 마이크로프로세서 : 메모리와 I/O가 프로세서 코어와 같은 패키지에 들어 있지 않는 프로세서
  - 마이크로 컴퓨터 : 모든 요소를 한 칩 안에 패키징



### 프로시저, 서브루틴, 함수

- 함수, 프로시저, 서브루틴는 코드를 재사용하는 주요 수단이다.
- 언어에 따라 이름만 다를 뿐 동일한 의미
- 함수를 호출하는 부분에서 함수를 실행하고 다시 원래 자리로 돌아올 방법이 필요
  - 이 과정은 상당히 많은 작업이 필요하며, 대부분의 기계는 이런 과정을 돕는 명령어를 제공한다.



### 스택

- 재귀(recursion)
  -  함수가 자기 자신을 호출
  - 재귀 함수가 제대로 작동하려면 반환 주소를 여럿 저장할 수 있어야 하며, 함수에서 호출 지점으로 반환할 때 저장된 주소 중 어떤 주소를 사용할지 결정할 수 있어야 한다.
- stack
  - LIFO 나중에 들어온 것이 먼저 나가는 구조
  - 스택 오버플로 : 스택에 물건을 푸시할 때, 더 이상 들어갈 공간이 없는 경우
  - 스택 언더플로 : 빈 스택에서 물건을 팝하는 경우
- 스택 프레임
  - 함수를 호출할 때 지역 변수도 스택에 저장하며, 각각의 함수 호출이 서로 독립적이게 된다.
  - 함수가 호출될 때마다 스택에 저장되는 데이터의 모음을 스택 프레임이라고 부른다.



### 인터럽트

- 인터럽트
  - 인터럽트 시스템은 적절한 신호가 들어오면 CPU 실행을 잠깐 중단시킬 수 있는 핀이나 전기 연결을 포함한다.
  - 대부분의 프로세서에는 인터럽트 시스템이 들어가 있다.
  - 장치 크기가 줄어듦에 따라 통합 주변장치가 들어 있고, 이런 장치들은 내부적으로 인터럽트 시스템에 연결되어 있다.
- 작동 방식
  - CPU가 주의를 기울여야 하는 주변장치는 인터럽트 요청을 생성
  - 프로세서는 현재 실행 중인 명령어를 끝까지 실행
  - 그 후 프로세서는 현재 실행 중인 프로그램을 잠시 중단시키고 인터럽트 핸들러(함수)라는 전혀 다른 프로글램을 실행
  - 인터럽트 핸들러가 필요한 작업을 다 마치면 원래 실행 중이던 프로그램이 중단된 위치부터 다시 실행

- 고려할 요소
  - 인터럽트에 대한 응답 시간 : 인터럽트 처리를 정해진 시간 안에 끝내야 한다.
  - 인터럽트를 서비스하고 나중에 다시 원래대로 돌아오기 위한 현재 상태를 저장할 방법이 필요하다.
    - 인터럽트 시스템은 서비스 후 돌아올 프로그램 위치를 스택에 저장
- 인터럽트 제어
  - 인터럽트 중단시킬 수 있는 마스크
  - 인터럽트 간의 우선순위에 따른 처리
  - 일정 시간이 지나면 인터럽틀르 발생시킬 수 있는 내장 타이머



### 상대 주소 지정

- 운영체제 or 운영체제 커널 : 각 프로그램을 서로 전환시켜 줄 수 있는 일종의 관리자 프로그램
- OS를 시스템 프로그램이라고 부르고 다른 모든 프로그램을 사용자 프로그램이나 프로세스라 부른다.
- OS는 타이머를 사용해 사용자 프로그램을 전환시켜줄지 판단하는데, 이러한 스케줄링 기법을 시분할이라 한다.
- 상대 주소 지정
  - 명령어에 들어 있는 주소를 0부터 시작하는 위치로 해석하지 않고, 명령어의 주소를 기준으로 하는 상대적인 주소로 해석



### 메모리 관리 장치

- 대부분의 마이크로프로세서에는 메모리 관리 장치(MMU)가 들어 있다.
  - MMU가 들어 있는 시스템은 가상 주소와 물리 주소를 구분한다.
  - MMU의 가상 주소 범위는 물리적 메모리 주소보다 큰 경우가 많다.



### 가상 메모리

- OS는 희소한 하드웨어 자원을 사용하려고 경합하는 프로그램들 사이의 자원 분배를 관리한다.
- 메모리도 OS가 관리하는 자원으로 OS는 MMU를 사용해 사용자 프로그램에게 가상 메모리를 제공한다.
- 요청받은 메모리가 사용가능한 메모리의 크기보다 클 경우
  - OS는 현재 필요하지 않은 메모리 페이지를 더 느리지만 더 용량이 큰 대용량 저장장치인 디스크로 옮긴다 - 스왑 아웃
  - 이런 스왑 아웃한 페이지에 프로그램이 접근하면 운영체제는 필요한 메모리 공간을 확보하고 요청받은 페이지를 다시 메모리로 불러들인다 - 스왑 인
  - 이러한 페이지 처리를 demand paging 이라고 한다.
- 스와핑이 일어나면 시스템 성능이 크게 저하된다.
- 성능 저하를 막기 위해 다양한 기법을 이용 ex) LRU



### 시스템 공간과  사용자 공간

- CPU에는 컴퓨터가 시스템 모드에 있는지 사용자 모드에 있는지 결정하는 비트가 어떤 레지스터 안에 들어 있다.
- I/O를 처리하는 명령어 등 일부 명령어는 특권 명령어라서 오직 시스템 모드에서만 실행할 수 있다.
- 트랩이나 시스템 콜이라고 부르는 특별한 명령어를 통해 사용자 모드에서 실행 중인 프로그램이 시스템 모드 프로그램에게 요청을 보낼 수 있다.
- 장점
  - 사용자 프로그램으로부터 운영체제를 보호하고, 사용자 프로그램을 다른 사용자 프로그램으로부터 보호
  - 사용자 프로그램이 MMU 등의 몇몇 요소에 손을 댈 수 없기 때문에 운영체제가 프로그램에 대한 자원 할당을 전적으로 제어할 수 있다.



### 메모리 계층과 성능

메모리 계층

빠르고 비쌈 <---------------------------------------------------------------->느리고 쌈

CPU - 레지스터 - L1캐시 - L2 캐시 - L3 캐시 - 주 메모리 - 대량 저장장치



### 코프로세서

- 프로세서 코어는 아주 복잡한 회로로 이루어져 있다.
- 몇 가지 연산을 코프로세서라는 더 단순한 회로에 위임하면 프로세서 코어가 일반적인 연산에 활용할 수 있는 공간을 더 확보할 수 있다.
- 일부 코프로세서는 다른 일은 처리하지 않고 데이터 복사만 담당하는데 이런 방식을 직접 메모리 접근이라 한다.



### 메모리상의 데이터 배치

- 메모리에 명령어만 담는게 아니라 데이터도 담을 수 있는데 이 경우 데이터는 정적 데이터다.
- 정적이라는 말은 얼마나 많은 메모리가 필요한지 알고 있다는 뜻
- 여러 데이터 영역을 서로 충돌하지 않게 배치할 수 있어야 한다.
- 동적 데이터는 프로그램을 실행하기 전에는 크기를 알 수 없는 데이터
  - 동적 데이터는 주로 정적 데이터가 차지하는 영역의 바로 위 영역에 쌓이며, 이를 힙이라 한다.
  - 더 많은 데이터를 저장해야 할 경우 스택은 아래로, 힙은 위로 늘어난다 - 충돌하지 않게 하는 것이 중요



### 프로그램 실행

- 라이브러리 : 관련 함수를 한데 모은 것
- 프로그램 전부를 한 파일에 저장할 수도 있지만, 이를 여러 파일로 나눠놓을 수도 있다
- 나누어 놓을 경우 여러 부분을 동시에 개발할 수 있다는 장점이 있지만 모든 조각을 하나로 엮거나 연결할 방법이 필요하다.
- 프로그램을 링크하기 편한 형식의 매개 파일로 나누고, 링커라는 특별한 프로그램을 사용해 여러 조각을 하나로 연결해 실행
- 실행과 링크가 가능한 형식은 현재 가장 유명한 매개 파일 형식
- 라이브러리를 프로그램의 나머지 부분과 직접 연결해 실행 파일을 만드는 방식을 정적 링크라 하며, 여러 프로그램에 쓰이기 때문에(여러 실행 파일에 반복적으로 들어가서 메모리 낭비를 막기위해) 공유 라이브러리를 사용하는 동적 링크를 만들었다.
- 진입점
  - 진입점은 프로그램의 첫 번째 명령어가 위치한 주소를 뜻한다.
  - 실제 프로그램이 실행될 때 가장 먼저 실행되는 명령어는 진입점에 있는 명령어가 아니다. 프로그램을 이루는 모든 부분이 하나로 합쳐져서 실행파일을 이룰 때 런타임 라이브러리가 추가된다. 이 런타임 라이브러리에 있는 명령어가 먼저 실행되고 나중에 진입점 명령어가 실행된다.



### 메모리 전력 소비

- 데이터를 메모리에서 옮기려면 전력이 소비된다.
- 전력 소비와 성능 사이의 균형을 잡는 것이 필요



---



## 데이터 구조와 처리

- 데이터 구조

  데이터를 조직화하는 표준적인 방법

  여러 유형의 메모리를 효율적으로 사용하기 위해 존재

### 기본 데이터 타입

- 프로그래밍 언어는 다양한 기본 데이터 타입을 제공
  1. 크기(비트 수)
  2. 해석(부호 존재 여부, 부동소수점 수, 문자, 포인터, 불리언)
- 포인터
  - 컴퓨터 아키텍처에 따라 결정되는 크기의 부호가 없는 정수에 불과하며, 정숫값이 아니라 메모리 주소로 해석
  - 원하는 값이 있는 위치를 포인터로 알 수 있다

### 배열

- 위치를 가리키는 인덱스, 구성하는 값을 원소라 하며, 같은 타입의 원소로 이루어진 집합

### 비트맵

- 비트의 배열
- 기본 연산
  - set(1로 만들기),
  - clear(0으로 만들기),
  - 비트가 1인지 검사,
  - 비트가 0인지 검사
- 배열 인덱스와 비트 마스크를 사용한 연산
  - 비트 설정하기 : 비트 or 마스크
  - 비트 지우기 : 비트 and (not 마스크)
  - 비트가 1인지 검사 : 비트 and 마스크 ≠ 0
  - 비트가 0인지 검사 : 비트 and 마스크 = 0

### 문자열

- 여러 문자로 이뤄진 시퀀스를 문자열이라 한다
- 문자열을 연산할 때도 길이를 알아야 한다

### 복합 데이터 타입

- 원하는 데이터 타입을 만들 수 있는 방법을 제공
  - 구조체, 구조체 멤버
  - 공용체
    - 공용체를 사용하면 메모리 공간 공유

### 단일 연결 리스트

- 데이터양이 정해져 있지 않으면 배열을 사용하는데 적합하지 않다 > 연결 리스트는 목록에 들어갈 원소 개수를 모르는 경우 배열보다 잘 작동한다
- 다음 원소 주소를 저장하는 포인터와 데이터로 이루어져 있다
- 리스트 원소는 연속적으로 위치할 필요가 없다

### 동적 메모리 할당

- 정적으로 할당된 데이터 영역 다음에 프로그램 런타임 라이브러리가 설정해주는 힙 영역이 존재
- 이 힙 영역이 프로그램에 사용할 수 있는 모든 데이터 메모리
- MMU가 있는 시스템에서는 런타임 라이브러리가 프로그램에게 필요한 메모리 용량을 판단해 요청
- 배열 등의 변수가 사용하는 메모리는 정적이다. 이런 변수에 할당된 주소는 바뀌지 않는다
- 리스트 노드와 같은 존재가 동적이다. 이런 동적인 대상에 사용할 메모리를 힙에서 얻는다
- 프로그램은 힙을 관리할 수 있어야 하며, 프로그램은 사용 중인 메모리를 알아야 하고, 사용 가능한 메모리도 알아야 한다

### 가비지 컬렉션

- 동적 메모리를 명시적으로 관리하면서 포인터를 잘못 사용할 때 문제점
  - 포인터를 사용해 존재하지 않는 메모리에 접근하거나
  - 프로세서의 메모리 경계에 맞지 않는 주소에 접근하면 예외가 발생
- 포인터가 없지만 동적 메모리 할당을 지원 → 가비지 컬렉션 구현
- 포인터 대신 참조를 사용, 참조는 포인터를 추상화해 비슷한 기능을 제공하지만 실제 메모리 주소를 노출하지 않는다
- 가비지 컬렉션을 사용하는 언어는 데이터 요소를 만들면서 이 요소가 사용할 메모리도 할당하는 new 연산자를 제공하는 경우가 있다
- 한 가지 문제는 프로그래머가 가비지 컬렉션 시스템을 제어할 수 없다

### 이중 연결 리스트

- 노드의 다음 원소에 대한 포인터뿐만 아니라 이전 원소에 대한 포인터도 들어 있는 리스트
- 노드당 부가 비용은 2배가 되지만, delete시 노드를 앞에서부터 방문할 필요가 없어진다
- 리스트 전체를 방문하지 않아도 원하는 위치에 노드를 추가, 삭제가 가능하다

### 계층적인 데이터 구조

- 데이터를 효율적으로 가져오고 싶은 경우
- 가장 간단한 계층적 데이터 구조는 2진 트리다
  - 노드가 최대 2개의 다른 노드와 연결될 수 있다
- 2진 트리에서 어떤 대상을 검색하는 연산은 트리 깊이에 의해 정의되는 함수다
  - 트리가 n계층만큼 아래로 내려간다면 검색 시 n번만 원소를 비교
  - 연결 리스트에서 n번 비교 ↔ 균형 잡힌 트리에선 log2n번 비교

### 데이터베이스

- 데이터베이스는 정해진 방식으로 조직화된 데이터 모음이다
- DBMS는 데이터베이스에 정보를 저장하고 읽어올 수 있게 해주는 프로그램이다
- B트리 데이터 구조를 활용한 시스템

### 객체 지향의 함정

- 객체에는 함수에 해당하는 메서드와 데이터에 해당하는 프로퍼티가 들어 있다

- 어떤 객체에 필요한 모든 데이터와 함수는 한 데이터 구조 안에 모여 있다

- 객체와 관련된 부가 비용이 어느 정도 존재, 객체는 전역적으로 알려진 함수 대신에 자신이 사용할 메서드에 대한 포인터를 가지고 다녀야 한다

  → 객체 내의 데이터가 데이터만 저장하는 데이터 구조처럼 꽉 짜여 있지 않으므로 성능이 결정적으로 중요할 때는 배열을 활용하는게 좋다

### 해시

- 일반적인 검색 메서드는 모두 데이터 구조를 순회하면서 비교를 여러 번 수행
- 일반적인 검색 메서드와 다른 접근 방법이 해싱이다
  - 일반적인 개념은 검색에 사용할 키(검색 시 동일성을 판단)에 대해, 이들을 균일하게 흩뿌려주는 해시 함수를 적용하는 것
- 해시 함수의 결과값을 사용해 키에 대응하는 데이터를 메모리에 저장할 수 있다. 따라서 해시 함수는 메모리 크기보다 작은 범위의 값을 만들어야 한다
  - 메모리 접근 성능이 떨어질 수 있기 때문
- 저장장치에 데이터를 저장하는 방법 중에는 해시 함수의 결과를 배열 인덱스로 활용하는 방법이 있다. 이런 배열을 해시 테이블이라 한다.
  - 해시 테이블 배열의 각 원소를 버킷이라 한다
- 좋은 해시 함수는 계산하기 쉬어야 하고, 키를 골고루 버킷에 뿌려줘야 한다

### 효율성과 성능

- 샤딩
  - 성능과 효율이 분리된 상황을 응용하는 방법
  - 다른 말로 수평 파티셔닝
  - 데이터베이스를 각각 다른 기계에서 실행되는 여러 샤드로 나누는 방식
  - 인터페이스를 통해 요청이 들어온 데이터베이스 연산을 모든 샤드에 전달 > 컨트롤러가 결과를 하나로 모음
  - 작업을 여러 작업자로 나눠 수행할 수 있어서 성능이 향상된다
- 맵디듀스
  - 샤딩의 변종
  - 컨트롤러가 중간 결과를 모으는 방법을 코드로 직접 작성 가능